import bpy
import os
import json
import math

upper_left = [-4.3202, 2.4302]
bottom_right = [4.3202, -2.4302]

height = bottom_right[1] - upper_left[1]
width = bottom_right[0] - upper_left[0]
 
input_width = 1920
input_height = 1080

body = bpy.data.objects["Body"]
head = bpy.data.objects["Head"]

Upper_Arm_L = bpy.data.objects["Upper_Arm_L"]
Upper_Arm_R = bpy.data.objects["Upper_Arm_R"]
Arm_L = bpy.data.objects["Arm_L"]
Arm_R = bpy.data.objects["Arm_R"]

body_parts =  [ "Nose", "Neck", "RShoulder", "RElbow", "RWrist", "LShoulder", "LElbow", "LWrist", "MidHip", "RHip", "RKnee", "RAnkle", "LHip", "LKnee", "LAnkle", "REye", "LEye", "REar", "LEar", "LBigToe", "LSmallToe", "LHeel", "RBigToe", "RSmallToe", "RHeel", "Background" ]

rotation_threshold = 4
body_threshold = 0.05

'''
TODO:
    
phase 1: visualization
    ✓ 1- initialize grease pencil objects for each keypoint
    ✓ 2- position each keypoint for each frame
    
phase 2: proof of concept
    ✓- replace keypoints with rig keypoints
    ✓- calculate slopes
    ✓- transfer slope data for rigging
    ✓- replace keypoints
    ✓- fix errors with constraints and detection confidence data 


phase 3: 
    1- conditional character poses
    2- multiple characters
    
    
phase 4: forced aligner for lip syncing 

'''

def process_json():
    
    processed_frames = []
    
    directory = "C:/Users/ereno/automated-2d-animation/output_json_folder"
    with os.scandir(directory) as frames:
        for frame in frames:
            with open(frame, 'r') as f:
                
                data = json.loads(f.read())
                keypoints_raw = data["people"][0]["pose_keypoints_2d"]
                
                keypoints = []
                    
                # Get x and y values, 
                # ignore the detection confidence for now 
                for i in range(0,len(keypoints_raw),3):  
                    x = keypoints_raw[i]
                    y = keypoints_raw[i + 1]
                    keypoints.append({"x":x,"y":y})
                
                processed_frames.append(keypoints)
            
    return processed_frames

     

def locate_position(body_part_index, frame, prev_frame):
    
    prev_x = prev_frame[body_part_index]["x"]
    prev_y = prev_frame[body_part_index]["y"]

    input_x = frame[body_part_index]["x"]
    input_y = frame[body_part_index]["y"]

    output_x  = upper_left[0] + ( (input_x / input_width) * width )
    output_y  = upper_left[1] + ( (input_y / input_height) * height )
    
    
    return output_x, output_y



def rotate(object, keypoint_index, frame, parent):
    
    angle = 0
    
    start_x = frame[keypoint_index]["x"]
    start_y = frame[keypoint_index]["y"]    
    end_x = frame[keypoint_index + 1]["x"]
    end_y = frame[keypoint_index + 1]["y"]

    # Find the slope angle
    if (end_x - start_x) != 0:
        angle = math.degrees(math.atan((end_y - start_y) / (end_x - start_x)))
    
    if(end_x < start_x):
        angle += 180
        
    rotation_y_value = angle - parent - 90
    
    # temporary fix for stabil.
    previous_y = object.rotation_euler[1]  
    
    if(abs(previous_y - rotation_y_value ) > rotation_threshold):
        object.rotation_euler[1] = math.radians(rotation_y_value)
    
    

    return angle
  
    

processed_frames = process_json()




upper_L = 0
upper_R = 0


for i in range(0, len(processed_frames)):
    
    
    for keypoint_index in range(0, 24):
        
        output_x, output_y = locate_position(keypoint_index, processed_frames[i-1], processed_frames[i-2], )
    
        object_name = "circle" + str(keypoint_index)
        
        obj = bpy.data.objects[object_name]
        obj.location = (output_x, 0, output_y)
        obj.keyframe_insert(data_path="location", frame = i)
        
        if(keypoint_index == 1):
            
            # temporary fix for stabil.
            previous_x = body.location[0]  
            
            if(abs(previous_x - output_x ) > body_threshold):
                
                print("frame index: ", i)
                print("prev_x, output_x ", previous_x, output_x)
                body.location = (output_x, 0, output_y)
                
            body.keyframe_insert(data_path="location", frame = i)
            
        
        # right upper arm
        elif(keypoint_index == 2):
            upper_R = rotate(Upper_Arm_R, keypoint_index, processed_frames[i], 0)
            Upper_Arm_R.keyframe_insert(data_path="rotation_euler", frame = i)
            
        # right arm
        elif(keypoint_index == 3):
            rotate(Arm_R, keypoint_index, processed_frames[i], upper_R - 90)
            Arm_R.keyframe_insert(data_path="rotation_euler", frame = i)
            upper_R = 0
        
        # left upper arm
        elif(keypoint_index == 5):
            upper_L = rotate(Upper_Arm_L, keypoint_index, processed_frames[i], 0)
            Upper_Arm_L.keyframe_insert(data_path="rotation_euler", frame = i)
        
        # left arm
        elif(keypoint_index == 6):
            rotate(Arm_L, keypoint_index, processed_frames[i], upper_L - 90)
            Arm_L.keyframe_insert(data_path="rotation_euler", frame = i)
            upper_L = 0
            
        
        











